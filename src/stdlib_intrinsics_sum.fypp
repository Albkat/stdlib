#:include "common.fypp"
#:set R_KINDS_TYPES = list(zip(REAL_KINDS, REAL_TYPES, REAL_SUFFIX))
#:set C_KINDS_TYPES = list(zip(CMPLX_KINDS, CMPLX_TYPES, CMPLX_SUFFIX))
#:set RC_KINDS_TYPES = R_KINDS_TYPES + C_KINDS_TYPES
#:set RANKS = range(2, MAXRANK + 1)

! This module is based on https://github.com/jalvesz/fast_math
submodule(stdlib_intrinsics) stdlib_intrinsics_sum
    !!Replacement for certain Fortran intrinsic functions offering either faster and/or more accurate implementations.
    !! ([Specification](../page/specs/stdlib_intrinsics.html))
    use stdlib_kinds
    use stdlib_constants
    implicit none

    integer, parameter :: chunk = 64
    
contains

!================= 1D Base implementations ============
#:for rk, rt, rs in RC_KINDS_TYPES
pure module function fsum_1d_${rs}$(a) result(s)
    ${rt}$, intent(in) :: a(:)
    ${rt}$ :: s
    ${rt}$ :: abatch(chunk)
    integer :: i, dr, rr
    ! -----------------------------
    dr = size(a)/chunk
    rr = size(a) - dr*chunk

    abatch = zero_${rs}$
    do i = 1, dr
      abatch(1:chunk) = abatch(1:chunk) + a(chunk*i-chunk+1:chunk*i)
    end do
    abatch(1:rr) = abatch(1:rr) + a(size(a)-rr+1:size(a))

    s = zero_${rs}$
    do i = 1, chunk/2
      s = s + abatch(i)+abatch(chunk/2+i)
    end do
end function

pure module function fsum_1d_${rs}$_mask(a,mask) result(s)
    ${rt}$, intent(in) :: a(:)
    logical, intent(in) :: mask(:)
    ${rt}$ :: s
    ${rt}$ :: abatch(chunk)
    integer :: i, dr, rr
    ! -----------------------------
    dr = size(a)/chunk
    rr = size(a) - dr*chunk

    abatch = zero_${rs}$
    do i = 1, dr
      abatch(1:chunk) = abatch(1:chunk) + merge( zero_${rs}$ , a(chunk*i-chunk+1:chunk*i) , mask(chunk*i-chunk+1:chunk*i) )
    end do
    abatch(1:rr) = abatch(1:rr) + merge( zero_${rs}$ , a(size(a)-rr+1:size(a)) , mask(size(a)-rr+1:size(a)) )
    
    s = zero_${rs}$
    do i = 1, chunk/2
        s = s + abatch(i)+abatch(chunk/2+i)
    end do
end function

pure module function fsum_kahan_1d_${rs}$(a) result(s)
    ${rt}$, intent(in) :: a(:)
    ${rt}$ :: s
    ${rt}$ :: sbatch(chunk)
    ${rt}$ :: cbatch(chunk)
    integer :: i, dr, rr
    ! -----------------------------
    dr = size(a)/(chunk)
    rr = size(a) - dr*chunk     
    sbatch = zero_${rs}$
    cbatch = zero_${rs}$
    do i = 1, dr
        call kahan_kernel( a(chunk*i-chunk+1:chunk*i) , sbatch(1:chunk) , cbatch(1:chunk) )
    end do
    call kahan_kernel( a(size(a)-rr+1:size(a)) , sbatch(1:rr) , cbatch(1:rr) )      

    s = zero_${rs}$
    do i = 1,chunk
        call kahan_kernel( sbatch(i) , s , cbatch(i) )
    end do
end function

pure module function fsum_kahan_1d_${rs}$_mask(a,mask) result(s)
    ${rt}$, intent(in) :: a(:)
    logical, intent(in) :: mask(:)
    ${rt}$ :: s
    ${rt}$ :: sbatch(chunk)
    ${rt}$ :: cbatch(chunk)
    integer :: i, dr, rr
    ! -----------------------------
    dr = size(a)/(chunk)
    rr = size(a) - dr*chunk     
    sbatch = zero_${rs}$
    cbatch = zero_${rs}$
    do i = 1, dr
        call kahan_kernel( a(chunk*i-chunk+1:chunk*i) , sbatch(1:chunk) , cbatch(1:chunk) , mask(chunk*i-chunk+1:chunk*i) )
    end do
    call kahan_kernel( a(size(a)-rr+1:size(a)) , sbatch(1:rr) , cbatch(1:rr) , mask(size(a)-rr+1:size(a)) )

    s = zero_${rs}$
    do i = 1,chunk
        call kahan_kernel( sbatch(i) , s , cbatch(i) )
    end do
end function
#:endfor

!================= N-D implementations ============
#:for rk, rt, rs in RC_KINDS_TYPES
#:for rank in RANKS
pure module function fsum_${rank}$d_${rs}$( x , mask ) result( s )
    ${rt}$, intent(in) :: x${ranksuffix(rank)}$
    logical, intent(in), optional :: mask${ranksuffix(rank)}$
    ${rt}$ :: s
    if(.not.present(mask)) then
        s = sum_recast(x,size(x))
    else
        s = sum_recast_mask(x,mask,size(x))
    end if
contains
    pure ${rt}$ function sum_recast(b,n)
      integer, intent(in) :: n
      ${rt}$, intent(in) :: b(n)
      sum_recast = fsum(b)
    end function
    pure ${rt}$ function sum_recast_mask(b,m,n)
      integer, intent(in) :: n
      ${rt}$, intent(in) :: b(n)
      logical, intent(in) :: m(n)
      sum_recast_mask = fsum(b,m)
    end function
end function

pure module function fsum_${rank}$d_dim_${rs}$( x , dim, mask ) result( s )
    ${rt}$, intent(in) :: x${ranksuffix(rank)}$
    integer, intent(in):: dim
    logical, intent(in), optional :: mask${ranksuffix(rank)}$
    ${rt}$ :: s${reduced_shape('x', rank, 'dim')}$
    integer :: j 

    if(.not.present(mask)) then
        if(dim<${rank}$)then
            do j = 1, size(x,dim=${rank}$)
                #:if rank == 2
                s${select_subarray(rank-1, [(rank-1, 'j')])}$ = fsum( x${select_subarray(rank, [(rank, 'j')])}$ )
                #:else
                s${select_subarray(rank-1, [(rank-1, 'j')])}$ = fsum( x${select_subarray(rank, [(rank, 'j')])}$, dim=dim )
                #:endif
            end do
        else
            do j = 1, size(x,dim=1)
                #:if rank == 2
                s${select_subarray(rank-1, [(1, 'j')])}$ = fsum( x${select_subarray(rank, [(1, 'j')])}$ )
                #:else
                s${select_subarray(rank-1, [(1, 'j')])}$ = fsum( x${select_subarray(rank, [(1, 'j')])}$, dim=${rank-1}$ )
                #:endif
            end do
        end if
    else 
        if(dim<${rank}$)then
            do j = 1, size(x,dim=${rank}$)
                #:if rank == 2
                s${select_subarray(rank-1, [(rank-1, 'j')])}$ = fsum( x${select_subarray(rank, [(rank, 'j')])}$, mask=mask${select_subarray(rank, [(rank, 'j')])}$ )
                #:else
                s${select_subarray(rank-1, [(rank-1, 'j')])}$ = fsum( x${select_subarray(rank, [(rank, 'j')])}$, dim=dim, mask=mask${select_subarray(rank, [(rank, 'j')])}$ )
                #:endif
            end do
        else
            do j = 1, size(x,dim=1)
                #:if rank == 2
                s${select_subarray(rank-1, [(1, 'j')])}$ = fsum( x${select_subarray(rank, [(1, 'j')])}$, mask=mask${select_subarray(rank, [(1, 'j')])}$ )
                #:else
                s${select_subarray(rank-1, [(1, 'j')])}$ = fsum( x${select_subarray(rank, [(1, 'j')])}$, dim=${rank-1}$, mask=mask${select_subarray(rank, [(1, 'j')])}$ )
                #:endif
            end do
        end if
    end if

end function
#:endfor
#:endfor

end submodule stdlib_intrinsics_sum
