#:include "common.fypp"
#:set R_KINDS_TYPES = list(zip(REAL_KINDS, REAL_TYPES, REAL_SUFFIX))
#:set C_KINDS_TYPES = list(zip(CMPLX_KINDS, CMPLX_TYPES, CMPLX_SUFFIX))
#:set KINDS_TYPES = R_KINDS_TYPES+C_KINDS_TYPES
!> The `stdlib_sparse_conversion` module provides sparse to sparse matrix conversion utilities.
!>
! This code was modified from https://github.com/jalvesz/FSPARSE by its author: Alves Jose
module stdlib_sparse_conversion
    use stdlib_kinds, only: int8, int16, int32, int64, sp, dp, xdp, qp
    use stdlib_sparse_kinds
    implicit none
    private

    public :: dense2coo, coo2dense, coo2csr, csr2coo
    public :: csr2sellc

    !> Conversion from dense to coo
    !> 
    !> Enables extracting the non-zero elements of a dense 2D matrix and
    !> storing those values in a COO format. The coo matrix is (re)allocated on the fly.
    interface dense2coo
        #:for k1, t1, s1 in (KINDS_TYPES)
        module procedure dense2coo_${s1}$
        #:endfor
    end interface

    !> Conversion from coo to dense
    !> 
    !> Enables creating a dense 2D matrix from the non-zero values tored in a COO format
    !> The dense matrix can be allocated on the fly if not pre-allocated by the user.
    interface coo2dense
        #:for k1, t1, s1 in (KINDS_TYPES)
        module procedure coo2dense_${s1}$
        #:endfor
    end interface

    !> Conversion from coo to csr
    !> 
    !> Enables transferring data from a COO matrix to a CSR matrix
    !> under the hypothesis that the COO is already ordered.
    interface coo2csr
        #:for k1, t1, s1 in (KINDS_TYPES)
        module procedure coo2csr_${s1}$
        #:endfor
    end interface

    !> Conversion from csr to coo
    !> 
    !> Enables transferring data from a CSR matrix to a COO matrix
    !> under the hypothesis that the CSR is already ordered.
    interface csr2coo
        #:for k1, t1, s1 in (KINDS_TYPES)
        module procedure csr2coo_${s1}$
        #:endfor
    end interface

    !> Conversion from csr to SELL-C
    !> 
    !> Enables transferring data from a CSR matrix to a SELL-C matrix
    !> It takes an optional parameter to decide the chunck size 4, 8 or 16
    interface csr2sellc
    #:for k1, t1, s1 in (KINDS_TYPES)
        module procedure csr2sellc_${s1}$
    #:endfor
    end interface

contains

    #:for k1, t1, s1 in (KINDS_TYPES)
    subroutine dense2coo_${s1}$(dense,COO)
        ${t1}$, intent(in) :: dense(:,:)
        type(COO_${s1}$), intent(inout) :: COO
        integer :: num_rows, num_cols, nnz
        integer :: i, j, idx

        num_rows = size(dense,dim=1)
        num_cols = size(dense,dim=2)
        nnz      = count( abs(dense) > tiny(1._${k1}$) )

        call COO%malloc(num_rows,num_cols,nnz)

        idx = 1
        do i = 1, num_rows
            do j = 1, num_cols
                if(abs(dense(i,j)) < tiny(1._${k1}$)) cycle
                COO%index(1,idx) = i
                COO%index(2,idx) = j
                COO%data(idx) = dense(i,j)
                idx = idx + 1
            end do
        end do
        COO%isOrdered = .true.
    end subroutine

    #:endfor

    #:for k1, t1, s1 in (KINDS_TYPES)
    subroutine coo2dense_${s1}$(COO,dense)
        type(COO_${s1}$), intent(in) :: COO
        ${t1}$, allocatable, intent(inout) :: dense(:,:)
        integer :: idx

        if(.not.allocated(dense)) allocate(dense(COO%nrows,COO%nrows),source=zero_${s1}$)
        do concurrent(idx = 1:COO%nnz)
            dense( COO%index(1,idx) , COO%index(2,idx) ) = COO%data(idx)
        end do
    end subroutine

    #:endfor

    #:for k1, t1, s1 in (KINDS_TYPES)
    subroutine coo2csr_${s1}$(COO,CSR)
        type(COO_${s1}$), intent(in)    :: COO
        type(CSR_${s1}$), intent(inout) :: CSR
        integer :: i

        CSR%nnz = COO%nnz; CSR%nrows = COO%nrows; CSR%ncols = COO%ncols
        CSR%base = COO%base; CSR%sym = COO%sym

        if( allocated(CSR%col) ) then
            CSR%col(1:COO%nnz)  = COO%index(2,1:COO%nnz)
            CSR%rowptr(1:CSR%nrows) = 0
            CSR%data(1:CSR%nnz) = COO%data(1:COO%nnz)
        else 
            allocate( CSR%col(CSR%nnz)  , source = COO%index(2,1:COO%nnz) )
            allocate( CSR%rowptr(CSR%nrows+1) , source = 0 )
            allocate( CSR%data(CSR%nnz) , source = COO%data(1:COO%nnz) )
        end if

        CSR%rowptr(1) = 1
        do i = 1, COO%nnz
            CSR%rowptr( COO%index(1,i)+1 ) = CSR%rowptr( COO%index(1,i)+1 ) + 1
        end do
        do i = 1, CSR%nrows
            CSR%rowptr( i+1 ) = CSR%rowptr( i+1 ) + CSR%rowptr( i )
        end do
    end subroutine

    #:endfor

    #:for k1, t1, s1 in (KINDS_TYPES)
    subroutine csr2coo_${s1}$(CSR,COO)
        type(CSR_${s1}$), intent(in)    :: CSR
        type(COO_${s1}$), intent(inout) :: COO
        integer :: i, j

        COO%nnz = CSR%nnz; COO%nrows = CSR%nrows; COO%ncols = CSR%ncols
        COO%base = CSR%base; COO%sym = CSR%sym

        if( .not.allocated(COO%data) ) then
            allocate( COO%data(CSR%nnz) , source = CSR%data(1:CSR%nnz) )
        else 
            COO%data(1:CSR%nnz) = CSR%data(1:CSR%nnz)
        end if

        if( .not.allocated(COO%index) ) allocate( COO%index(2,CSR%nnz) )
        
        do i = 1, CSR%nrows
            do j = CSR%rowptr(i), CSR%rowptr(i+1)-1
                COO%index(1:2,j) = [i,CSR%col(j)]
            end do
        end do
    end subroutine

    #:endfor

    #:for k1, t1, s1 in (KINDS_TYPES)
    subroutine csr2sellc_${s1}$(CSR,SELLC,chunk)
        !> csr2sellc: This function enables transfering data from a CSR matrix to a SELL-C matrix
        !> This algorithm was gracefully provided by Ivan Privec and adapted by Jose Alves
        type(CSR_${s1}$), intent(in)      :: CSR
        type(SELLC_${s1}$), intent(inout) :: SELLC
        integer, intent(in), optional :: chunk
        ${t1}$, parameter :: zero = zero_${s1}$
        integer :: i, j, num_chunks

        if(present(chunk)) SELLC%chunk_size = chunk

        SELLC%nrows = CSR%nrows; SELLC%ncols = CSR%ncols
        SELLC%base  = CSR%base;  SELLC%sym = CSR%sym
        associate( nrows=>SELLC%nrows, ncols=>SELLC%ncols, nnz=>SELLC%nnz, &
        &         chunk_size=>SELLC%chunk_size     )
        !-------------------------------------------
        ! csr rowptr to SELL-C chunked rowptr
        num_chunks = (nrows + chunk_size - 1)/chunk_size
        allocate( SELLC%rowptr(num_chunks+1) )
        block
            integer :: cidx, rownnz, chunknnz
            SELLC%rowptr(1) = 1
            cidx = 1
            do i = 1, nrows, chunk_size
                chunknnz = 0
                ! Iterate over rows in a given chunk
                do j = i, min(i+chunk_size-1,nrows)
                    rownnz = CSR%rowptr(j+1) - CSR%rowptr(j)
                    chunknnz = max(chunknnz,rownnz)
                end do
                SELLC%rowptr(cidx+1) = SELLC%rowptr(cidx) + chunknnz
                cidx = cidx + 1
            end do
            nnz = SELLC%rowptr(num_chunks+1) - 1
        end block
        !-------------------------------------------
        ! copy values and colum index
        allocate(SELLC%col(chunk_size,nnz), source = -1)
        allocate(SELLC%data(chunk_size,nnz), source = zero )
        block
            integer :: lb, ri, iaa, iab, rownnz
            do i = 1, num_chunks

                lb = SELLC%rowptr(i)

                ! Loop over rows of a chunk
                do j = (i-1)*chunk_size + 1, min(i*chunk_size,nrows)
    
                    ri = j - (i - 1)*chunk_size
                    
                    rownnz = CSR%rowptr(j+1) - CSR%rowptr(j) - 1
                    iaa    = CSR%rowptr(j)
                    iab    = CSR%rowptr(j+1) - 1
                    
                    SELLC%col(ri,lb:lb+rownnz)  = CSR%col(iaa:iab)
                    SELLC%data(ri,lb:lb+rownnz) = CSR%data(iaa:iab)
                
                end do
            end do
         end block
        end associate
    end subroutine

    #:endfor
    
end module stdlib_sparse_conversion