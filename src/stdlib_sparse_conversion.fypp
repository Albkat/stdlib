#:include "common.fypp"
#:set R_KINDS_TYPES = list(zip(REAL_KINDS, REAL_TYPES, REAL_SUFFIX))
#:set C_KINDS_TYPES = list(zip(CMPLX_KINDS, CMPLX_TYPES, CMPLX_SUFFIX))
#:set KINDS_TYPES = R_KINDS_TYPES+C_KINDS_TYPES
!> The `stdlib_sparse_conversion` module provides sparse to sparse matrix conversion utilities.
!>
! This code was modified from https://github.com/jalvesz/FSPARSE by its author: Alves Jose
submodule(stdlib_sparse_kinds) stdlib_sparse_conversion
    use stdlib_sorting, only: sort
    implicit none

    !> Sort arrays of a COO matrix
    !> 
    interface sort_coo
        module procedure sort_coo_unique
    #:for k1, t1, s1 in (KINDS_TYPES)
        module procedure sort_coo_unique_${s1}$
    #:endfor
    end interface

contains

    #:for k1, t1, s1 in (KINDS_TYPES)
    module subroutine dense2coo_${s1}$(dense,COO)
        ${t1}$, intent(in) :: dense(:,:)
        type(COO_${s1}$), intent(inout) :: COO
        integer :: num_rows, num_cols, nnz
        integer :: i, j, idx

        num_rows = size(dense,dim=1)
        num_cols = size(dense,dim=2)
        nnz      = count( abs(dense) > tiny(1._${k1}$) )

        call COO%malloc(num_rows,num_cols,nnz)

        idx = 1
        do i = 1, num_rows
            do j = 1, num_cols
                if(abs(dense(i,j)) < tiny(1._${k1}$)) cycle
                COO%index(1,idx) = i
                COO%index(2,idx) = j
                COO%data(idx) = dense(i,j)
                idx = idx + 1
            end do
        end do
        COO%is_sorted = .true.
    end subroutine

    #:endfor

    #:for k1, t1, s1 in (KINDS_TYPES)
    module subroutine coo2dense_${s1}$(COO,dense)
        type(COO_${s1}$), intent(in) :: COO
        ${t1}$, allocatable, intent(inout) :: dense(:,:)
        integer :: idx

        if(.not.allocated(dense)) allocate(dense(COO%nrows,COO%nrows),source=zero_${s1}$)
        do concurrent(idx = 1:COO%nnz)
            dense( COO%index(1,idx) , COO%index(2,idx) ) = COO%data(idx)
        end do
    end subroutine

    #:endfor

    #:for k1, t1, s1 in (KINDS_TYPES)
    module subroutine coo2csr_${s1}$(COO,CSR)
        type(COO_${s1}$), intent(in)    :: COO
        type(CSR_${s1}$), intent(inout) :: CSR
        integer :: i

        CSR%nnz = COO%nnz; CSR%nrows = COO%nrows; CSR%ncols = COO%ncols
        CSR%storage = COO%storage

        if( allocated(CSR%col) ) then
            CSR%col(1:COO%nnz)  = COO%index(2,1:COO%nnz)
            CSR%rowptr(1:CSR%nrows) = 0
            CSR%data(1:CSR%nnz) = COO%data(1:COO%nnz)
        else 
            allocate( CSR%col(CSR%nnz)  , source = COO%index(2,1:COO%nnz) )
            allocate( CSR%rowptr(CSR%nrows+1) , source = 0 )
            allocate( CSR%data(CSR%nnz) , source = COO%data(1:COO%nnz) )
        end if

        CSR%rowptr(1) = 1
        do i = 1, COO%nnz
            CSR%rowptr( COO%index(1,i)+1 ) = CSR%rowptr( COO%index(1,i)+1 ) + 1
        end do
        do i = 1, CSR%nrows
            CSR%rowptr( i+1 ) = CSR%rowptr( i+1 ) + CSR%rowptr( i )
        end do
    end subroutine

    #:endfor

    #:for k1, t1, s1 in (KINDS_TYPES)
    module subroutine csr2dense_${s1}$(CSR,dense)
        type(CSR_${s1}$), intent(in) :: CSR
        ${t1}$, allocatable, intent(inout) :: dense(:,:)
        integer :: i, j

        if(.not.allocated(dense)) allocate(dense(CSR%nrows,CSR%nrows),source=zero_${s1}$)
        if( CSR%storage == sparse_full) then
            do i = 1, CSR%nrows
                do j = CSR%rowptr(i), CSR%rowptr(i+1)-1
                    dense(i,CSR%col(j)) = CSR%data(j)
                end do
            end do
        else
            do i = 1, CSR%nrows
                do j = CSR%rowptr(i), CSR%rowptr(i+1)-1
                    dense(i,CSR%col(j)) = CSR%data(j)
                    if( i == CSR%col(j) ) cycle
                    dense(CSR%col(j),i) = CSR%data(j)
                end do
            end do
        end if
    end subroutine

    #:endfor

    #:for k1, t1, s1 in (KINDS_TYPES)
    module subroutine csr2coo_${s1}$(CSR,COO)
        type(CSR_${s1}$), intent(in)    :: CSR
        type(COO_${s1}$), intent(inout) :: COO
        integer :: i, j

        COO%nnz = CSR%nnz; COO%nrows = CSR%nrows; COO%ncols = CSR%ncols
        COO%storage = CSR%storage

        if( .not.allocated(COO%data) ) then
            allocate( COO%data(CSR%nnz) , source = CSR%data(1:CSR%nnz) )
        else 
            COO%data(1:CSR%nnz) = CSR%data(1:CSR%nnz)
        end if

        if( .not.allocated(COO%index) ) allocate( COO%index(2,CSR%nnz) )
        
        do i = 1, CSR%nrows
            do j = CSR%rowptr(i), CSR%rowptr(i+1)-1
                COO%index(1:2,j) = [i,CSR%col(j)]
            end do
        end do
    end subroutine

    #:endfor

    #:for k1, t1, s1 in (KINDS_TYPES)
    module subroutine csr2ell_${s1}$(CSR,ELL,num_nz_rows)
        type(CSR_${s1}$), intent(in)    :: CSR
        type(ELL_${s1}$), intent(inout) :: ELL
        integer, intent(in), optional :: num_nz_rows !> number of non zeros per row

        integer :: i, j, num_nz_rows_, adr1, adr2
        !-------------------------------------------
        num_nz_rows_ = 0
        if(present(num_nz_rows)) then
            num_nz_rows_ = num_nz_rows
        else 
            do i = 1, CSR%nrows
                num_nz_rows_ = max(num_nz_rows_, CSR%rowptr( i+1 ) - CSR%rowptr( i ) )
            end do
        end if
        call ELL%malloc(CSR%nrows,CSR%ncols,num_nz_rows_)
        !-------------------------------------------
        do i = 1, CSR%nrows
            adr1 = CSR%rowptr(i)
            adr2 = min( adr1+num_nz_rows_ , CSR%rowptr(i+1)-1)
            do j = adr1, adr2
                ELL%index(i,j-adr1+1) = CSR%col(j)
                ELL%data(i,j-adr1+1)  = CSR%data(j)
            end do
        end do
    end subroutine

    #:endfor

    #:for k1, t1, s1 in (KINDS_TYPES)
    module subroutine csr2sellc_${s1}$(CSR,SELLC,chunk)
        !> csr2sellc: This function enables transfering data from a CSR matrix to a SELL-C matrix
        !> This algorithm was gracefully provided by Ivan Privec and adapted by Jose Alves
        type(CSR_${s1}$), intent(in)      :: CSR
        type(SELLC_${s1}$), intent(inout) :: SELLC
        integer, intent(in), optional :: chunk
        ${t1}$, parameter :: zero = zero_${s1}$
        integer :: i, j, num_chunks

        if(present(chunk)) SELLC%chunk_size = chunk

        SELLC%nrows = CSR%nrows; SELLC%ncols = CSR%ncols
        SELLC%storage = CSR%storage
        associate( nrows=>SELLC%nrows, ncols=>SELLC%ncols, nnz=>SELLC%nnz, &
        &         chunk_size=>SELLC%chunk_size     )
        !-------------------------------------------
        ! csr rowptr to SELL-C chunked rowptr
        num_chunks = (nrows + chunk_size - 1)/chunk_size
        allocate( SELLC%rowptr(num_chunks+1) )
        block
            integer :: cidx, rownnz, chunknnz
            SELLC%rowptr(1) = 1
            cidx = 1
            do i = 1, nrows, chunk_size
                chunknnz = 0
                ! Iterate over rows in a given chunk
                do j = i, min(i+chunk_size-1,nrows)
                    rownnz = CSR%rowptr(j+1) - CSR%rowptr(j)
                    chunknnz = max(chunknnz,rownnz)
                end do
                SELLC%rowptr(cidx+1) = SELLC%rowptr(cidx) + chunknnz
                cidx = cidx + 1
            end do
            nnz = SELLC%rowptr(num_chunks+1) - 1
        end block
        !-------------------------------------------
        ! copy values and colum index
        allocate(SELLC%col(chunk_size,nnz), source = -1)
        allocate(SELLC%data(chunk_size,nnz), source = zero )
        block
            integer :: lb, ri, iaa, iab, rownnz
            do i = 1, num_chunks

                lb = SELLC%rowptr(i)

                ! Loop over rows of a chunk
                do j = (i-1)*chunk_size + 1, min(i*chunk_size,nrows)
    
                    ri = j - (i - 1)*chunk_size
                    
                    rownnz = CSR%rowptr(j+1) - CSR%rowptr(j) - 1
                    iaa    = CSR%rowptr(j)
                    iab    = CSR%rowptr(j+1) - 1
                    
                    SELLC%col(ri,lb:lb+rownnz)  = CSR%col(iaa:iab)
                    SELLC%data(ri,lb:lb+rownnz) = CSR%data(iaa:iab)
                
                end do
            end do
         end block
        end associate
    end subroutine

    #:endfor

    #:for k1, t1, s1 in (KINDS_TYPES)
    recursive subroutine quicksort_i_${s1}$(a, b, first, last)
        integer, parameter :: wp = sp
        integer, intent(inout) :: a(*) !! reference table to sort
        ${t1}$, intent(inout)  :: b(*) !! secondary real data to sort w.r.t. a
        integer, intent(in)     :: first, last
        integer  :: i, j, x, t
        ${t1}$ :: d

        x = a( (first+last) / 2 )
        i = first
        j = last
        do
            do while (a(i) < x)
                i=i+1
            end do
            do while (x < a(j))
                j=j-1
            end do
            if (i >= j) exit
            t = a(i);  a(i) = a(j);  a(j) = t
            d = b(i);  b(i) = b(j);  b(j) = d
            i=i+1
            j=j-1
        end do
        if (first < i-1) call quicksort_i_${s1}$(a, b, first, i-1)
        if (j+1 < last)  call quicksort_i_${s1}$(a, b, j+1, last)
    end subroutine 

    #:endfor

    subroutine sort_coo_unique( a, n, num_rows, num_cols )
        !! Sort a 2d array in increasing order first by index 1 and then by index 2
        integer, intent(inout) :: a(2,*)
        integer, intent(inout) :: n
        integer, intent(in) :: num_rows
        integer, intent(in) :: num_cols

        integer :: stride, adr0, adr1, dd
        integer :: n_i, pos, ed
        integer, allocatable :: count_i(:), count_i_aux(:), rows_(:), cols_(:)
        !---------------------------------------------------------
        ! Sort a first time with respect to first index using count sort
        allocate( count_i( 0:num_rows ) , source = 0 )
        do ed = 1, n
            count_i( a(1,ed) ) = count_i( a(1,ed) ) + 1
        end do
        do n_i = 2, num_rows
            count_i(n_i) = count_i(n_i) + count_i(n_i-1)
        end do
        allocate( count_i_aux( 0:num_rows ) , source = count_i )

        allocate( rows_(n), cols_(n) )
        do ed = n, 1, -1
            n_i = a(1,ed)
            pos = count_i(n_i)
            rows_(pos) = a(1,ed)
            cols_(pos) = a(2,ed)
            count_i(n_i) = count_i(n_i) - 1
        end do
        !---------------------------------------------------------
        ! Sort with respect to second column
        do n_i = 1, num_rows
            adr0 = count_i_aux(n_i-1)+1
            adr1 = count_i_aux(n_i)
            dd = adr1-adr0+1
            if(dd>0) call sort(cols_(adr0:adr1))
        end do
        !---------------------------------------------------------
        ! Remove duplicates
        do ed = 1,n
            a(1:2,ed) = [rows_(ed),cols_(ed)]
        end do
        stride = 0
        do ed = 2, n
            if( a(1,ed) == a(1,ed-1) .and. a(2,ed) == a(2,ed-1) ) then
                stride = stride + 1
            else
                a(1:2,ed-stride) = a(1:2,ed)
            end if
        end do
        n = n - stride
    end subroutine

    #:for k1, t1, s1 in (KINDS_TYPES)
    subroutine sort_coo_unique_${s1}$( a, data, n, num_rows, num_cols )
        !! Sort a 2d array in increasing order first by index 1 and then by index 2
        ${t1}$, intent(inout) :: data(*)
        integer, intent(inout) :: a(2,*)
        integer, intent(inout) :: n
        integer, intent(in) :: num_rows
        integer, intent(in) :: num_cols

        integer :: stride, adr0, adr1, dd
        integer :: n_i, pos, ed
        integer, allocatable :: count_i(:), count_i_aux(:), rows_(:), cols_(:)
        ${t1}$, allocatable :: temp(:)
        !---------------------------------------------------------
        ! Sort a first time with respect to first index using Count sort
        allocate( count_i( 0:num_rows ) , source = 0 )
        do ed = 1, n
            count_i( a(1,ed) ) = count_i( a(1,ed) ) + 1
        end do
        do n_i = 2, num_rows
            count_i(n_i) = count_i(n_i) + count_i(n_i-1)
        end do
        allocate( count_i_aux( 0:num_rows ) , source = count_i )

        allocate( rows_(n), cols_(n), temp(n) )
        do ed = n, 1, -1
            n_i = a(1,ed)
            pos = count_i(n_i)
            rows_(pos) = a(1,ed)
            cols_(pos) = a(2,ed)
            temp(pos)  = data(ed)
            count_i(n_i) = count_i(n_i) - 1
        end do
        !---------------------------------------------------------
        ! Sort with respect to second colum using a quicksort
        do n_i = 1, num_rows
            adr0 = count_i_aux(n_i-1)+1
            adr1 = count_i_aux(n_i)
            dd = adr1-adr0+1
            if(dd>0) call quicksort_i_${s1}$(cols_(adr0),temp(adr0),1,dd)
        end do
        !---------------------------------------------------------
        ! Remove duplicates
        do ed = 1,n
            a(1:2,ed) = [rows_(ed),cols_(ed)]
        end do
        data(1:n) = temp(1:n)
        stride = 0
        do ed = 2, n
            if( a(1,ed) == a(1,ed-1) .and. a(2,ed) == a(2,ed-1) ) then
                data(ed-1-stride) = data(ed-1-stride) + data(ed)
                data(ed) = data(ed-1-stride)
                stride = stride + 1
            else
                a(1:2,ed-stride) = a(1:2,ed)
                data(ed-stride) = data(ed)
            end if
        end do
        n = n - stride
    end subroutine

    #:endfor

    module subroutine coo2ordered(COO,sort_data)
        class(COO_type), intent(inout) :: COO
        logical, intent(in), optional :: sort_data
        integer, allocatable :: itemp(:,:)
        logical :: sort_data_
        
        if(COO%is_sorted) return

        sort_data_ = .false.
        if(present(sort_data)) sort_data_ = sort_data

        select type (COO)
            type is( COO_type )
                call sort_coo(COO%index, COO%nnz, COO%nrows, COO%ncols)
            #:for k1, t1, s1 in (KINDS_TYPES)
            type is( COO_${s1}$ )
                block
                ${t1}$, allocatable :: temp(:)
                if( sort_data_ ) then
                    call sort_coo(COO%index, COO%data, COO%nnz, COO%nrows, COO%ncols)
                    allocate( temp(COO%nnz) , source=COO%data(1:COO%nnz) )
                else 
                    call sort_coo(COO%index, COO%nnz, COO%nrows, COO%ncols)
                    allocate( temp(COO%nnz) )
                end if
                call move_alloc( temp , COO%data )
                end block
            #:endfor
        end select
        
        allocate( itemp(2,COO%nnz) , source=COO%index(1:2,1:COO%nnz) )
        call move_alloc( itemp , COO%index )

        COO%is_sorted = .true.
    end subroutine

end submodule