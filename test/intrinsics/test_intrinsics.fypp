#:include "common.fypp"
#:set R_KINDS_TYPES = list(zip(REAL_KINDS, REAL_TYPES, REAL_SUFFIX))
#:set C_KINDS_TYPES = list(zip(CMPLX_KINDS, CMPLX_TYPES, CMPLX_SUFFIX))
#:set RC_KINDS_TYPES = R_KINDS_TYPES + C_KINDS_TYPES

module test_intrinsics
    use testdrive, only : new_unittest, unittest_type, error_type, check, skip_test
    use stdlib_kinds, only: sp, dp, xdp, qp, int8, int16, int32, int64
    use stdlib_intrinsics
    use stdlib_math, only: swap
    implicit none
    
contains

!> Collect all exported unit tests
subroutine collect_suite(testsuite)
    !> Collection of tests
    type(unittest_type), allocatable, intent(out) :: testsuite(:)

    testsuite = [ &
        new_unittest('sum', test_sum), &
        new_unittest('dot_product', test_dot_product) &
    ]
end subroutine

subroutine test_sum(error)
    !> Error handling
    type(error_type), allocatable, intent(out) :: error

    !> Internal parameters and variables
    integer, parameter :: n = 1e3, ncalc = 3, niter = 100
    real(sp) :: u
    integer :: iter, i, j
    !====================================================================================
    #:for k1, t1, s1 in R_KINDS_TYPES
    block
        ${t1}$, allocatable :: x(:)
        ${t1}$, parameter :: total_sum = 4*atan(1._${k1}$), tolerance = epsilon(1._${k1}$)*100
        ${t1}$ :: xsum(ncalc), meanval(ncalc), err(ncalc)
        logical, allocatable :: mask(:), nmask(:)

        allocate(x(n))
        do i = 1, n 
            x(i) = 8*atan(1._${k1}$)*(real(i,kind=${k1}$)-0.5_${k1}$)/real(n,kind=${k1}$)**2
        end do
        allocate(mask(n),source=.false.); mask(1:n:2) = .true.
        allocate(nmask(n)); nmask = .not.mask
        ! scramble array
        do i = 1, n
            call random_number(u) 
            j = 1 + floor(n*u)
            call swap( x(i), x(j) )
            call swap( mask(i), mask(j) )
            call swap( nmask(i), nmask(j) )
        end do
        
        err(:) = 0._${k1}$
        do iter = 1, niter
            xsum(1) = sum(x)        ! compiler intrinsic
            xsum(2) = fsum_kahan(x) ! chunked Kahan summation
            xsum(3) = fsum(x)       ! chunked summation
            err(1:ncalc) = err(1:ncalc) + abs(1._${k1}$-xsum(1:ncalc)/total_sum)
        end do
        err(1:ncalc) = err(1:ncalc) / niter 
        
        call check(error, all(err(:)<tolerance) , "real sum is not accurate" )
        if (allocated(error)) return

        err(:) = 0._${k1}$
        do iter = 1, niter
            xsum(1) = sum(x,mask)+sum(x,nmask) ! compiler intrinsic
            xsum(2) = fsum_kahan(x,mask)+fsum_kahan(x,nmask) ! chunked Kahan summation
            xsum(3) = fsum(x,mask)+fsum(x,nmask) ! chunked summation
            err(1:ncalc) = err(1:ncalc) + abs(1._${k1}$-xsum(1:ncalc)/total_sum)
        end do
        err(1:ncalc) = err(1:ncalc) / niter 
        
        call check(error, all(err(:)<tolerance) , "masked real sum is not accurate" )
        if (allocated(error)) return
    end block
    #:endfor

    #:for k1, t1, s1 in C_KINDS_TYPES
    block
        ${t1}$, allocatable :: x(:)
        real(${k1}$), parameter :: total_sum = 4*atan(1._${k1}$), tolerance = epsilon(1._${k1}$)*100
        real(${k1}$) :: err(ncalc)
        ${t1}$ :: xsum(ncalc), meanval(ncalc)
        logical, allocatable :: mask(:), nmask(:)

        allocate(x(n))
        do i = 1, n
            x(i) = complex(&
                8*atan(1._${k1}$)*(real(i,kind=${k1}$)-0.5_${k1}$)/real(2*n,kind=${k1}$)**2,&
                8*atan(1._${k1}$)*(real(i+n,kind=${k1}$)-0.5_${k1}$)/real(2*n,kind=${k1}$)**2)
        end do
        allocate(mask(n),source=.false.); mask(1:n:2) = .true.
        allocate(nmask(n)); nmask = .not.mask
        ! scramble array
        do i = 1, n
            call random_number(u) 
            j = 1 + floor(n*u)
            call swap( x(i), x(j) )
            call swap( mask(i), mask(j) )
            call swap( nmask(i), nmask(j) )
        end do
        
        err(:) = 0._${k1}$
        do iter = 1, niter
            xsum(1) = sum(x)        ! compiler intrinsic
            xsum(2) = fsum_kahan(x) ! chunked Kahan summation
            xsum(3) = fsum(x)       ! chunked summation
            err(1:ncalc) = err(1:ncalc) + abs(1._${k1}$-(xsum(1:ncalc)%re+xsum(1:ncalc)%im)/total_sum)
        end do
        err(1:ncalc) = err(1:ncalc) / niter 
        
        call check(error, all(err(:)<tolerance) , "complex sum is not accurate" )
        if (allocated(error)) return

        err(:) = 0._${k1}$
        do iter = 1, niter
            xsum(1) = sum(x,mask)+sum(x,nmask) ! compiler intrinsic
            xsum(2) = fsum_kahan(x,mask)+fsum_kahan(x,nmask) ! chunked Kahan summation
            xsum(3) = fsum(x,mask)+fsum(x,nmask) ! chunked summation
            err(1:ncalc) = err(1:ncalc) + abs(1._${k1}$-(xsum(1:ncalc)%re+xsum(1:ncalc)%im)/total_sum)
        end do
        err(1:ncalc) = err(1:ncalc) / niter 
        
        call check(error, all(err(:)<tolerance) , "complex masked sum is not accurate" )
        if (allocated(error)) return
    end block
    #:endfor

end subroutine

subroutine test_dot_product(error)
    !> Error handling
    type(error_type), allocatable, intent(out) :: error

    !> Internal parameters and variables
    integer, parameter :: n = 1e3, ncalc = 3, niter = 100
    real(sp) :: u
    integer :: iter, i, j
    !====================================================================================
    #:for k1, t1, s1 in R_KINDS_TYPES
    block
        ${t1}$, allocatable :: x(:)
        ${t1}$, parameter :: total_sum = 4*atan(1._${k1}$), tolerance = epsilon(1._${k1}$)*100
        ${t1}$ :: xsum(ncalc), meanval(ncalc), err(ncalc)

        allocate(x(n))
        do i = 1, n 
            x(i) = sqrt( 8*atan(1._${k1}$)*(real(i,kind=${k1}$)-0.5_${k1}$)/real(n,kind=${k1}$)**2 )
        end do
        ! scramble array
        do i = 1, n
            call random_number(u) 
            j = 1 + floor(n*u)
            call swap( x(i), x(j) )
        end do
        
        err(:) = 0._${k1}$
        do iter = 1, niter
            xsum(1) = dot_product(x,x) ! compiler intrinsic
            xsum(2) = fprod_kahan(x,x) ! chunked Kahan summation
            xsum(3) = fprod(x,x)       ! chunked summation
            err(1:ncalc) = err(1:ncalc) + abs(1._${k1}$-xsum(1:ncalc)/total_sum)
        end do
        err(1:ncalc) = err(1:ncalc) / niter 
        
        call check(error, all(err(:)<tolerance) , "real dot_product is not accurate" )
        if (allocated(error)) return
    end block
    #:endfor

    #:for k1, t1, s1 in C_KINDS_TYPES
    block
        ${t1}$, allocatable :: x(:)
        real(${k1}$), parameter :: total_sum = 4*atan(1._${k1}$), tolerance = epsilon(1._${k1}$)*100
        real(${k1}$) :: err(ncalc)
        ${t1}$ :: xsum(ncalc), meanval(ncalc)

        allocate(x(n))
        do i = 1, n
            x(i) = complex(&
                sqrt(8*atan(1._${k1}$)*(real(i,kind=${k1}$)-0.5_${k1}$)/real(2*n,kind=${k1}$)**2),&
                sqrt(8*atan(1._${k1}$)*(real(i+n,kind=${k1}$)-0.5_${k1}$)/real(2*n,kind=${k1}$)**2))
        end do
        ! scramble array
        do i = 1, n
            call random_number(u) 
            j = 1 + floor(n*u)
            call swap( x(i), x(j) )
        end do
        
        err(:) = 0._${k1}$
        do iter = 1, niter
            xsum(1) = dot_product(x,x) ! compiler intrinsic
            xsum(2) = fprod_kahan(x,x) ! chunked Kahan dot_product
            xsum(3) = fprod(x,x)       ! chunked dot_product
            err(1:ncalc) = err(1:ncalc) + abs(1._${k1}$-(xsum(1:ncalc)%re+xsum(1:ncalc)%im)/total_sum)
        end do
        err(1:ncalc) = err(1:ncalc) / niter 
        
        call check(error, all(err(:)<tolerance) , "complex dot_product is not accurate" )
        if (allocated(error)) return
    end block
    #:endfor

end subroutine
    
end module test_intrinsics

program tester
    use, intrinsic :: iso_fortran_env, only : error_unit
    use testdrive, only : run_testsuite, new_testsuite, testsuite_type
    use test_intrinsics, only : collect_suite
    implicit none
    integer :: stat, is
    type(testsuite_type), allocatable :: testsuites(:)
    character(len=*), parameter :: fmt = '("#", *(1x, a))'

    stat = 0

    testsuites = [ &
        new_testsuite("sparse", collect_suite) &
        ]

    do is = 1, size(testsuites)
        write(error_unit, fmt) "Testing:", testsuites(is)%name
        call run_testsuite(testsuites(is)%collect, error_unit, stat)
    end do

    if (stat > 0) then
        write(error_unit, '(i0, 1x, a)') stat, "test(s) failed!"
        error stop
    end if
end program